<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gSOAP WS-Security: The mecevp streaming message encryption and decryption engine</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="mecevp">The mecevp streaming message encryption and decryption engine</a></h1>The gSOAP mecevp engine encrypts and decrypts messages using the EVP interface of OpenSSL. It supports envelope encryption/decryption with public and private RSA keys and symmetric encryption with shared secret keys. Streaming and buffered message encryption modes are supported.<p>
An encryption and decryption algorithm and mode is selected with one of the following:<p>
<ul>
<li><a class="el" href="mecevp_8h.html#a8">SOAP_MEC_ENV_ENC_DES_CBC</a> envelope encryption with triple DES CBC</li><li><a class="el" href="mecevp_8h.html#a8">SOAP_MEC_ENV_ENC_DES_CBC</a> envelope decryption with triple DES CBC</li><li><a class="el" href="mecevp_8h.html#a6">SOAP_MEC_ENC_DES_CBC</a> symmetric encryption with triple DES CBC</li><li><a class="el" href="mecevp_8h.html#a6">SOAP_MEC_ENC_DES_CBC</a> symmetric decryption with triple DES CBC</li></ul>
<p>
Algorithm options:<p>
<ul>
<li><a class="el" href="mecevp_8h.html#a5">SOAP_MEC_STORE</a> buffer all output in memory</li></ul>
<p>
The mecevp engine wraps the EVP API with four new functions:<p>
<ul>
<li><a class="el" href="mecevp_8c.html#a9">soap_mec_init</a> to initialize the engine</li><li><a class="el" href="mecevp_8c.html#a10">soap_mec_update</a> to encrypt/decrypt a message part</li><li><a class="el" href="mecevp_8c.html#a11">soap_mec_final</a> to finalize encryption/decryption</li><li><a class="el" href="mecevp_8c.html#a12">soap_mec_cleanup</a> to deallocate the engine and buffers</li></ul>
<p>
All cipher data is written and read in base64 format.<p>
A higher-level interface for message encryption/decryption in parts (such as individual XML elements) is defined by two new functions:<p>
<ul>
<li><a class="el" href="mecevp_8c.html#a13">soap_mec_begin</a> to begin a streaming sequence of encryptions/decryptions</li><li><a class="el" href="mecevp_8c.html#a14">soap_mec_start</a> to start encryption/decryption of a message part</li><li><a class="el" href="mecevp_8c.html#a15">soap_mec_stop</a> to stop encryption/decryption of a message part</li><li><a class="el" href="mecevp_8c.html#a16">soap_mec_end</a> to end the sequence and deallocate the engine buffers</li></ul>
<p>
Compile all source codes with -DWITH_OPENSSL and link with ssl and crypto libraries.<p>
Here is an example to encrypt a message while streaming it to the output. The example uses the public key of the recipient/reader of the message. The recipient/reader uses its private key to decrypt. Envelope encryption is used with SOAP_MEC_ENV_ENC_DES_CBC, which means an ephemeral secret key is generated and encrypted with the public key. This encrypted secret key should be communicated to the recipient/reader with the message to decrypt:<p>
<div class="fragment"><pre><span class="preprocessor">    #include "<a class="code" href="mecevp_8h.html">mecevp.h</a>"</span>
    <a class="code" href="structsoap__mec__data.html">soap_mec_data</a> mec;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="mecevp_8h.html#a8">SOAP_MEC_ENV_ENC_DES_CBC</a>;
    FILE *fd = fopen(<span class="stringliteral">"key.pem"</span>, <span class="stringliteral">"r"</span>);
    EVP_PKEY *pubk;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key;
    <span class="keywordtype">int</span> keylen;
    <span class="keywordflow">if</span> (...) <span class="comment">// key file contains public key?</span>
      pubk = PEM_read_PUBKEY(fd, NULL, NULL, NULL);
    <span class="keywordflow">else</span> <span class="comment">// key file contains certificate</span>
    { X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
      pubk = X509_get_pubkey(cert);
      X509_free(cert);
    }
    fclose(fd);
    key = soap_malloc(soap, <a class="code" href="mecevp_8h.html#a20">soap_mec_size</a>(alg, pubk));
    <span class="keywordflow">if</span> (soap_begin_send(soap)
     || <a class="code" href="mecevp_8h.html#a16">soap_mec_begin</a>(soap, &amp;mec, alg, pubk, key, &amp;keylen)
     || <a class="code" href="mecevp_8h.html#a17">soap_mec_start</a>(soap, NULL)
     || soap_out_ns__Object(soap, <span class="stringliteral">"ns:Object"</span>, 0, &amp;object, NULL)
     || <a class="code" href="mecevp_8h.html#a18">soap_mec_stop</a>(soap)
     || <a class="code" href="smdevp_8h.html#a15">soap_smd_end</a>(soap, &amp;mec)
     || soap_end_send(soap))
    { <a class="code" href="mecevp_8h.html#a24">soap_mec_cleanup</a>(soap, &amp;mec); <span class="comment">// clean up when error</span>
      soap_print_fault(soap, stderr);
    }
    EVP_PKEY_free(pubk);
</pre></div><p>
The decryption by the recipient/reader requires the ephemeral encrypted secret key generated by soap_mec_begin by the sender (as set above) to decrypt the message using envelope decryption with SOAP_MEC_ENV_DEC_DES_CBC.<p>
<div class="fragment"><pre><span class="preprocessor">    #include "<a class="code" href="mecevp_8h.html">mecevp.h</a>"</span>
    <a class="code" href="structsoap__mec__data.html">soap_mec_data</a> mec;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="mecevp_8h.html#a9">SOAP_MEC_ENV_DEC_DES_CBC</a>;
    FILE *fd = fopen(<span class="stringliteral">"key.pem"</span>, <span class="stringliteral">"r"</span>);
    EVP_PKEY *privk = PEM_read_PrivateKey(fd, NULL, NULL, <span class="stringliteral">"password"</span>);
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key;
    <span class="keywordtype">int</span> keylen;
    fclose(fd);
    key = ... <span class="comment">// value set as above by sender</span>
    keylen = ... <span class="comment">// value set as above by sender</span>
    <span class="keywordflow">if</span> (soap_begin_recv(soap)
     || <a class="code" href="mecevp_8h.html#a16">soap_mec_begin</a>(soap, &amp;mec, alg, privk, key, &amp;keylen)
     || <a class="code" href="mecevp_8h.html#a17">soap_mec_start</a>(soap)
     || soap_in_ns__Object(soap, <span class="stringliteral">"ns:Object"</span>, &amp;object, NULL) == NULL
     || <a class="code" href="mecevp_8h.html#a18">soap_mec_stop</a>(soap)
     || <a class="code" href="mecevp_8h.html#a19">soap_mec_end</a>(soap, &amp;mec)
     || soap_end_recv(soap))
    { <a class="code" href="mecevp_8h.html#a24">soap_mec_cleanup</a>(soap, &amp;mec); <span class="comment">// clean up when error</span>
      soap_print_fault(soap, stderr);
    }
    EVP_PKEY_free(privk);
</pre></div><p>
Note that the encrypted secret key can be send in the clear or stored openly, since only the recipient/reader will be able to decode it for use in message decryption.<p>
Symmetric encryption and decryption can be used if both parties can safely share a secret symmetric key that no other party has access to. We use SOAP_MEC_ENC_DES_CBC for encryption and SOAP_MEC_DEC_DES_CBC for decryption using a 160-bit triple DES key.<p>
Here is an example to encrypt a message using a shared secret key while streaming it to the output.<p>
<div class="fragment"><pre><span class="preprocessor">    #include "<a class="code" href="mecevp_8h.html">mecevp.h</a>"</span>
    <a class="code" href="structsoap__mec__data.html">soap_mec_data</a> mec;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="mecevp_8h.html#a6">SOAP_MEC_ENC_DES_CBC</a>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[20] = { ... }; <span class="comment">// shared secret triple DES key</span>
    <span class="keywordtype">int</span> keylen = 20;
    <span class="keywordflow">if</span> (soap_begin_send(soap)
     || <a class="code" href="mecevp_8h.html#a16">soap_mec_begin</a>(soap, &amp;mec, alg, NULL, key, &amp;keylen)
     || <a class="code" href="mecevp_8h.html#a17">soap_mec_start</a>(soap, NULL)
     || soap_out_ns__Object(soap, <span class="stringliteral">"ns:Object"</span>, 0, &amp;object, NULL)
     || <a class="code" href="mecevp_8h.html#a18">soap_mec_stop</a>(soap)
     || <a class="code" href="smdevp_8h.html#a15">soap_smd_end</a>(soap, &amp;mec)
     || soap_end_send(soap))
    { <a class="code" href="mecevp_8h.html#a24">soap_mec_cleanup</a>(soap, &amp;mec); <span class="comment">// clean up when error</span>
      soap_print_fault(soap, stderr);
    }
</pre></div><p>
The decryption by the recipient/reader requires the same shared secret key to decrypt the message using envelope decryption with SOAP_MEC_DEC_DES_CBC. This key is secret and unencrypted, so it should never be shared with any other party besides the sender/writer and recipient/reader.<p>
<div class="fragment"><pre><span class="preprocessor">    #include "<a class="code" href="mecevp_8h.html">mecevp.h</a>"</span>
    <a class="code" href="structsoap__mec__data.html">soap_mec_data</a> mec;
    ns__Object object;
    <span class="keywordtype">int</span> alg = <a class="code" href="mecevp_8h.html#a7">SOAP_MEC_DEC_DES_CBC</a>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[20] = { ... }; <span class="comment">// shared secret triple DES key</span>
    <span class="keywordtype">int</span> keylen = 20;
    <span class="keywordflow">if</span> (soap_begin_recv(soap)
     || <a class="code" href="mecevp_8h.html#a16">soap_mec_begin</a>(soap, &amp;mec, alg, NULL, key, &amp;keylen)
     || <a class="code" href="mecevp_8h.html#a17">soap_mec_start</a>(soap)
     || soap_in_ns__Object(soap, <span class="stringliteral">"ns:Object"</span>, &amp;object, NULL) == NULL
     || <a class="code" href="mecevp_8h.html#a18">soap_mec_stop</a>(soap)
     || <a class="code" href="mecevp_8h.html#a19">soap_mec_end</a>(soap, &amp;mec)
     || soap_end_recv(soap))
    { <a class="code" href="mecevp_8h.html#a24">soap_mec_cleanup</a>(soap, &amp;mec); <span class="comment">// clean up when error</span>
      soap_print_fault(soap, stderr);
    }
</pre></div><p>
Note: the mecevp engine uses callbacks of the gSOAP engine that were introduced in version 2.8.1. Earlier gSOAP version releases are not compatible with the mecevp plugin and engine. <hr size="1"><address style="align: right;"><small>Generated on Fri Jan 14 09:45:26 2011 for gSOAP WS-Security by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
